异星工厂 mod 和 scenario 制作教程

作者 YagaoDirac（github.com/yagaodirac）

1，这是什么
这是一篇讲如何制作异星工厂mod和场景的教程。
为了真实的使用文中所讲的技术来开发mod和场景，你需要有足够的英语阅读能力，足够的lua上的代码编写能力。一定的查阅编程接口文档的能力。如果不具备这3个能力，你可能会感到非常吃力，并且我不会在这个文档里面讲述这些话题。

2，文件结构
最简单的办法就是在mod站上去，按下载量排序，找个下载量大的，尺寸小的mod，下下来，看他的文件结构。
里面比较值得说的是info.json文件里面，有一个 "name" 。这个字段是最重要的，一定要小心。我就拿我的动态水来举例了，我的那个文件里面的写法是"name": "DynamicWater"。与此配合的是一个叫"version" 的字段，我的mod里面是"version": "0.2.5"，于是，你需要在mods文件夹下建一个文件夹，这个文件夹是 DynamicWater_0.2.5 ，也就是name，下划线，版本号。游戏只认这个名字。
mod文件夹有2种状态，如果直接放文件夹，是可以的，但是在传播的时候，包括上传的mod站的时候，是要用压缩包的形式。随便找一个东西，压缩成zip形式就行了。当然，你的压缩包的名字也必须是 name，下划线，版本号 格式的。也就是说，压缩包里面的第一层，应该是一个和压缩包的名字完全一样的文件夹。如果文件夹形式和压缩包形式同时存在，游戏好像是优先认文件夹形式，如此一来，开发的时候就会很方便。
这个"name"字段还有一个很重要的功能，就是当你要加入图片的时候，对这个字段做调整可以得到文件夹的相对路径。如果是在游戏的默认基础mod，就是传说中的base，在mod管理器里面就是base 1.0，也就是传说中的原版，他里面的图片的路径是以"__base__/"开头的，这个路径会让游戏去找游戏目录下面的base文件夹。这个是特殊的，mod里面是类似的格式，但是游戏会知道去mod压缩包，或者文件夹里面找。还是拿我的mod举例，"__DynamicWater__/"，很清楚了吧，反正就是前后都加2个下划线。这个加下划线的形式在remote模块里面的某些命令里面好像也会用到，我还没研究过，反正就是跨mod的代码要牵扯remote模块。具体的可以参考我后面要提到的一个调试mod。
info.json里面还有2个值得说的，一个是"title"，这个字段决定你的mod在很多地方显示的时候的名字，包括游戏里面和mod站。另外一个非常重要的细节，"factorio_version"，现在的游戏是1.0版本，不是1.0.0，你们在写的时候，一定要小心，如果写成1.0.0，那你的mod在任何情况下都是无法安装的。
文件结构里面还有一个非常重要的事情。如果你的mod在文件夹状态可以安装，但是在zip状态就无法安装，那就是你的文件，文件夹里面，有不是标准英语字符的其他字符，比如中文。我推荐只使用 大小写，数字，减号，下划线，圆点 来给所有文件，文件夹命名。

3，文档
之前有朋友在问，其实你们的游戏安装目录下面就有。如果是steam版本，那么你会在某个文件夹层级里面看到bin,data,doc-html， 这个最长的，doc-html，就是文档。当然也可以在网上找到。
里面比较值得提的事情是，工厂c++的部分好像并不想区分不同的entity，而是根据里面所含的字段来决定有一些什么样的功能，所以在LuaEntity.html里面有非常非常非常多的内容。而且这个entity好像还是从一个叫control的地方继承出来的。如果不清楚自己要找的功能是否在这两个里面，那估计进去搜一下还是很好的。
另外就是，推荐提前读一下这些文档，尤其是几个超级大的，至少看看里面都在说什么。还有就是名字不是以lua开头的，都是结构性的东西，提前读。

4，开发环境
我之前用过vs code，和visual studio2019，Pi-C大神还推荐过一个，Geany，非常感谢他的推荐，可惜我没有去用过。最近认识的seancheey，是BeltRouter的作者，也是正在进行中的Blueprinter的作者，推荐的是Intellij的免费版本。
开发环境最重要的事情是辅助功能，这里面就牵扯到2个插件，一个叫EmmyLua，一个叫Factorio api 什么什么。就我所知，vs code里面的第二个插件有问题，所以可以认为只有EmmyLua。Intellij里面是全的。vs2019还不知道，应该是都没有。Geany就更不知道了。
反正结论是，如果想无脑，就去下Intellij的免费版本，然后在里面安装EmmyLua和Factorio Api的什么什么自动补全。
如果要单独写lua，还需要一个lua分发版本，好像是叫lua distribution。版本无所谓，工厂的lua好像是5.2，但是如果用5.3应该是差不多的，两个版本好像只有“是否有整数类型”的差异，其他差异都比较小，应该不会影响。安装好之后，需要在Intellij里面设置一下lua的exe的路径。（exe是windows上的可执行文件的扩展名）

5，调试
除了属于lua的调试方法，还有一些工厂的单独的。先说代码层面的。
5，1，有一个库，应该是工厂官方做的，叫serpent，在github上有。但是你们真正需要用的，多半是serpent.block，例如， local a ={3,4,5,b=11,c=22}，然后log(serpent.block(a))，于是在log文件里面就会有a的全部内容。log文件的地址，如果是steam版本，通常是在c盘里面，就是保存mod的那个地方的旁边。有2个log文件，current就是这次的，之前一次的在旁边一个log里面。好像不用具体说吧，看到就知道了。如果是单独的版本，那就更好找了。
游戏里面的调试，主要有
5，1，game.print，game.players[1].print，两个打印，当然，多数时候用第一个。
5，2，/c 和 /sc ，第一个就不说了。第二个好像是server command，这种情况下是没有player index的。用得少。
5，3，有一个大神叫x2605，好像是韩国人，他写了2个mod，名字都是lua api开头的。反正一个的开启是ctrl shift v，一个是shift f3。这里面比较值得说的是gvv，在gvv的面板的最后一个tab里面，第二个按钮，里面，右边有2个text editor，第一个是一个/sc 开头的，鼠标指上去，应该是单击右键就可以复制。最简单的处理方法是，把这个复制到你的mod和场景（最好是两个都）的control.lua的开头，然后找到最最开头，把 /sc 去掉，不然编译不过。然后再重新进地图，在gvv里面，就可以在第二个tab里面看到所有的全局变量。这个东西非常好用。当然gvv的第一个tab里面是可以快速测试代码的，测试好了再往lua文件里面复制也是非常好用的技巧。还有一个就是第3个tab里面，game object，右边，有entity_prototypes，最下面还有tile_prototypes，这个比官方给的调试工具还好用。在最上面还可以关闭所有的nil项的显示，右边有搜索。反正这个工具应该是最最核心的一个。
5，4，去异星工厂官网下一个单独的版本，用命令行开游戏，所有的log的结果会在这个命令行窗口里面显示，可以快速查看。很方便。当然，维持2个版本也是非常好的习惯，一个用来开发。一个steam版本保持正常状态，既可以测试，又可以挖石头，多好。
在单独的用来开发的版本里面，找到data\base\scenarios，进去把不用的删了。但是无论如何要留一个。我现在留的是sandbox。当然可以自己写一个场景，最好是空场景，当作调试专用。data\base\campaigns里面是任务关，反正开发用，这个里面的东西就可以直接删了。这个事情做完以后，在开始游戏的时候，就只有一个场景可以选，会顺手一些。
5，5，官方其实提供了2个游戏内的还比较好用的功能，但是老实说也一般，在键盘设置的最下面把，反正默认的按键是ctrl shift f 和 ctrl shift e，我用得少，没什么印象了。这个里面可以快速的查看到lua里面的数据结构，在做原型的时候还是多少有点用的。反正就是你们一定要小心那种，到底是一层{还是2层，这个经常出问题。
5，6，在主菜单下面，按住ctrl alt（或者我记错了，可能是ctrl shift或者别的什么组合），鼠标点options，进去，里面会多一个按钮，里面有一些东西，我觉得没什么用。

6，lua语言直接相关
就不重复一些能在系统的教程里面找到的东西了。这儿主要说一些个人体会。
现在的代码组织风格主要有3个，过程式，对象式，和所谓的函数式。我个人的感觉是，过程式就不用考虑了，除非你的代码够短。函数式严格的说是对象式的一个子集，所以也没有必要觉得好像有很神奇的功效，不会延年益寿的。如果希望做一个足够大足够漂亮的mod，或者地图，或者配合使用的mod专用地图，地图专用mod，我还是建议尽量考虑对象式的代码组织风格。
lua语言本身是支持非常重型的，大规模的对象式变成的，只是执行效率实在是不can敢bu恭ren维du，毕竟不是为了效率而存在的语言。如果你在cpp一类的语言里面有大量的组织大型对象式风格代码的经验，那么恭喜，你依然可以把你的经验原原本本的用到lua上，并且获得非常理想的效果。
lua语言里面和oop直接相关的特性，主要有，metatable（把__newindex，__index的效果好好研究一下，会有奇效，当然还有rawget和rawset配合使用），closure（闭包，但是不是让你们用这个做class的替代，严格的说只是配合别的特性用，但是必须很熟悉），for循环（lua的for loop有一些特殊说法，不直观，书里面有，当然也是可以完全回避掉的），require（只是为了多文件编程），next函数（这不是lua可以实现的功能，是在c里面写的），整数（好像是5.3才引入的，总之看看呗），还有就是 字符串常量 的写法和 注释。
反正就是不要觉得自己读了很多lua代码，所以就一定知道所有lua的特性了。我读过很多代码，我发现几乎很少有什么lua代码用到了我刚刚说的那些特性，所以lua代码通常是过程式的。主要是我不想用很糟糕的语言来评价那些代码，你们懂的，伤害的面太大了，没必要。

另外还有一个我还没刷到的教程，就是assert，比如写错了一个东西，在lua里面可以手动规定报错。

另外就是，我还是推荐一些具体写法吧。
control.lua的开头
new = {}//ctor
mt = {}//metatable
然后写require，就当成cpp的include来写。
require("custom player")

之后就可以在custom player里面写。
通常在cpp里面，一个类就写一个构造函数，通常都能够用。在lua里面，一个等效的做法需要分2步。
mt.custom_player={}
mt.custom_player.__newindex = function () return//new fields are not allowed.
mt.custom_player.__index = function (我还不知道这个应该怎么写)
总之里面就是判断一下，某些不让改的，就不要改，直接return完事
end

上面的部分定义了metatable，之后定义构造函数
new.custom_player=function(player)
local result = {}
result.字段1 = 什么什么
result.字段2 = 什么什么
result.setmetatable(mt.custom_player)
return result
end

如果希望有多种构造函数，可以写成
new.custom_player={}
new.custom_player.style_1 = function(player)
第一种构造
end

在任何地方用的时候，只要写一句
cst_ply = new.custom_player(entity.character)，一类的，就可以了。

这个代码风格就非常的oop了。

7，rcon。
我都还没用过rcon。其实说起来也不复杂，rcon是一个在网上能查到的协议，就是游戏里面在用。异星工厂的主体进程有一个tcp（记错了就不知道了，也有可能是udp）的端口，直接拿任何东西往这个端口上连就完事了。之后从lua里面，调用工厂的rcon里面的某个功能，可以发东西出来，然后另外一遍从tcp收东西，如果要发送任何东西，也是往这个tcp里面发。也就是说rcon是外部代码通过标准的sockets和游戏进程直接通信的一个协议，而游戏里面发出来的东西是在lua代码里面定义的。
此外，还有一个，就是之前clusterio里面用的方法，在 游戏 >>> 外部代码 这个方向的时候，可以用game.write_file，把要输出的东西写到文件里面，然后外部代码去读这个文件。路径是在存档路径里面的。而 外部代码 >>> 游戏 方向，则比较麻烦，因为好像只能发送lua代码，所以还是个麻烦事情。反正这个是可行的，具体的去读clusterio代码和他们的github上的某些资料。

8，创建物体。
surface里面有一个叫create_entity的函数。这个函数有一个坑。就是工厂里面的所有物品，都有2个很核心的字段，一个是type，一个是name。name就不说了，创建物品的时候当然要写这个name。但是type其实也在这个函数里面有涉及。对不同的type的原型，这个create_entity函数做的事情是不同的，所需要的参数也是不同的。一个例子就是，扔手雷的时候，手雷飞出去的时候就是一个entity，他的type是projectile。如果要凭空创建，就必须要按照projectile的需要的参数来写。在文档LuaSurface里面，这个函数的参数列表下面有非常长的一串东西，其中有一个就是说的，对projectile，有2个字段是必须要的，speed和max_range。如果按照写别的类型的entity的那种创建的参数来写，就会报错。总之就是这个地方的文档，写全了，但是没有说这个地方的用法。
至于这个type怎么查，最简单的方法，游戏内ctrl shift e，写物品的名字去搜，搜出来的右边就有蓝色的字，那个还能给一个链接，里面会有这个type的信息。或者也可以用x2605大神的gvv（lua api global variable viewer），第4个tab，左边game，然后右边的树形图里面的entity_prototypes，里面找到物品的名字，点开，type是其中一个字段。
专门写一下这个细节，有点坑。

9，制作简单原型
还是之前的手雷的事情。游戏里面ctrl shift e，搜grenade，在grenade的右边会有那个projectile的蓝色的小字，点一下就会有一个网页，里面就会介绍projectile的里面的所有字段的含义。这个地方有一个非常重要的事情，就是通过这个资料可以快速的确定哪些字段是必须要有的。简单原型往往只处理事情的一个方面，就像是在ue4的component，所以需要尽量的减少无关的事情。比如要得到一个范围伤害，那么最简单的方法之一就是拿手雷的爆炸的效果来改。我的mod里面的这个版本好像还不是最精简的。总之就是这个方法，你们自己看着写。
之后记得在lua里面组装起来。如此一来就得到了一个复合的。比如一个sprite来负责显示，而伤害则使用刚刚介绍的没有画面显示的爆炸。我还给这种爆炸取了个名字，叫无烟雷。

10，图片。
路径就不说了。前面提了，mod名字前后加2个下划线的路径就是mod的根目录，就是原版的__base__。所以改mod名字还是一个很麻烦的事情。
icon的默认尺寸是32x32像素。所以如果图片是超过这个的，那么scale字段的行为就会比较奇怪。我之前就遇到64x64像素的icon，scale写0.5，结果没有缩放，要写比0.5更小的，才能看到效果。当然这个是次要的问题。
一些相关的参考
https://wiki.factorio.com/Prototype/Sprite
这个是sprite的参考，在ctrl shift e里面，随便找一个有图片的东西，找到他的图片的字段，点进去，新的ui在最上面就会有一个sprite的蓝色的小字，点一下就有这个链接了。

https://wiki.factorio.com/Types/IconSpecification
这个是
https://wiki.factorio.com/Prototype/Recipe
进来，在IconSpecification里面。重点是看最下面的例子，里面有多图层的icon图标的写法。他那个scale = 0.5是有效的，因为他的icon_size是32。然后shift是像素。
用这个方法就可以在代码里面批量的生成一堆icon，比手动做图片要省事得多。

11，永动机
或者叫，如何让机器不消耗能源。
很简单，但是不直观。组装机一类的东西里面，会有一个字段叫energy_source，从原型文档里面也可以看到这个字段，他里面的3个东西好像都是不能删的。其中，type，可以写成void。就懂了吧。改了以后，外面的energy_usage字段随便怎么写都无所谓了。
我不知道singistics的永动机是怎么做的，我猜应该是类似的情况。
顺便说一下。1，如果不希望在游戏过程中改变组装机里面在执行的配方，有2个方法，1是在原型里面写，文档里面有。2是在luaentity.html里面可以看到有一个东西叫recipe_locked，好像是这个名字，改成true就行了。方法1是在data里面写，方法2是在control里面写。如果要制作大量的固定配方的机器，方法2具有非常大的灵活性，可以用相同的原型，甚至是用原版的。
还有一个细节，矿机好像有点问题，改能源类型的话可能就会出错，所以尽量不要用。可以写一个recipe，ingredient写成{}，results里面写一个ore，就可以模拟矿机。而且矿机的log有5000行，很难搞。


12，如何生成一个空的surface
game.surface，第二个参数可以好好研究一下。方法也很简单，进游戏，在地图选项那个地方，设置上自己要的，然后进游戏以后，log(serpent.block(game.surfaces[1].map_generate_setting))，然后去读日志就完事了。
但是无论如何，有2个东西是扔不掉的，水和石头。水的情况呢，我在我的代码里面有示范，大概思路就是surface.get_tile，然后判断，是不是"water"或者"deepwater"，是的话就改成"grass-2"。这个草2是比较舒服的一种，当然也可以用别的。然后石头的情况是surface.find_entities_filtered，里面的area写event.area(这个event就是on_chunk_generated传进来的参数event)里面的type写"simple-entity"，返回值是一个表，对里面的每一个调用destroy就行了。
还有一个办法，就是有个mod叫singistics，它提供了另外一个方法，就是在原型里面，把石头，树，矿那些，相关的自动生成，关掉，是在原型里面做的。但是它的方法无法处理水。
总之就是有很多东西是既可以在原型里面改，又可以在运行时里面改。

13，如何显示完全自定义的图片
记住一些细节，1是当使用type是sprite的原型的时候，rendering.draw_sprite的第一个参数是sprite的name，而不是type.name的格式。就是说，原型那边是type = "sprite", name = "test"，那么在调用函数的时候，第一个参数要写"test"，而不能写"sprite.test"。不知道以后的版本会不会改，反正现在的版本是只接受短的版本的。除了sprite之外的其他的情况就必须把type写清楚，也就是长的写法。这个很绕。
然后单独显示一个sprite没什么用，还是要配合别的。配合第8条的那个无烟雷，应该是可以做一些很有趣的效果的。所以好好学lua吧，别偷懒。
这个地方有一个bug，就是time_to_live至少要2，不然不显示。就是说，如果只显示一帧，也要写2。


结语：
这好像就是我现在知道的所有的细节了，其中还包括一些我没有真的用过的，也是最近才学的，比如lua的语言特性。希望对大家有帮助。当然，不要拿我的动态水做参考，那玩意儿写得太烂了，以后有时间可能要回锅。



